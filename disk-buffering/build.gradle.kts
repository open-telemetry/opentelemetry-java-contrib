import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import de.undercouch.gradle.tasks.download.Download
import ru.vyarus.gradle.plugin.animalsniffer.AnimalSniffer

plugins {
  id("otel.java-conventions")
  id("otel.publish-conventions")
  id("com.github.johnrengelman.shadow")
  id("me.champeau.jmh") version "0.7.3"
  id("ru.vyarus.animalsniffer") version "2.0.0"
  id("com.squareup.wire") version "5.3.1"
  id("de.undercouch.download")
}

description = "Exporter implementations that store signals on disk"
otelJava.moduleName.set("io.opentelemetry.contrib.exporters.disk")

java {
  sourceCompatibility = JavaVersion.VERSION_1_8
  targetCompatibility = JavaVersion.VERSION_1_8
}

dependencies {
  api("io.opentelemetry:opentelemetry-sdk")
  compileOnly("com.google.auto.value:auto-value-annotations")
  annotationProcessor("com.google.auto.value:auto-value")
  signature("com.toasttab.android:gummy-bears-api-21:0.6.1:coreLib@signature")
  testImplementation("org.mockito:mockito-inline")
  testImplementation("io.opentelemetry:opentelemetry-sdk-testing")
}

animalsniffer {
  sourceSets = listOf(java.sourceSets.main.get())
}

// Always having declared output makes this task properly participate in tasks up-to-date checks
tasks.withType<AnimalSniffer> {
  reports.text.required.set(true)
}

// Attaching animalsniffer check to the compilation process.
tasks.named("classes").configure {
  finalizedBy("animalsnifferMain")
}

jmh {
  warmupIterations.set(0)
  fork.set(2)
  iterations.set(5)
  timeOnIteration.set("5s")
  timeUnit.set("ms")
}

val protoVersion = "1.5.0"
val protoArchive = layout.buildDirectory.file("archives/opentelemetry-proto-$protoVersion.zip").get().asFile

wire {
  java {}

  sourcePath {
    srcDir(layout.buildDirectory.dir("protos/opentelemetry-proto-$protoVersion"))
  }

  root(
    "opentelemetry.proto.trace.v1.TracesData",
    "opentelemetry.proto.metrics.v1.MetricsData",
    "opentelemetry.proto.logs.v1.LogsData",
  )
}

afterEvaluate {
  tasks {
    val downloadProtoArchive by registering(Download::class) {
      onlyIf { !protoArchive.exists() }
      src("https://github.com/open-telemetry/opentelemetry-proto/archive/v$protoVersion.zip")
      dest(protoArchive)
    }

    val unzipProtoArchive by registering(Copy::class) {
      dependsOn(downloadProtoArchive)
      from(zipTree(protoArchive))
      into(layout.buildDirectory.dir("protos"))
    }

    named("generateMainProtos") {
      dependsOn(unzipProtoArchive)
    }
  }
}

tasks.named<ShadowJar>("shadowJar") {
  archiveClassifier.set("")
  configurations = emptyList() // To avoid embedding any dependencies as we only need to rename some local packages.
  relocate("io.opentelemetry.proto", "io.opentelemetry.diskbuffering.proto")
  mustRunAfter("jar")
}

// The javadoc from wire's generated classes has errors that make the task that generates the "javadoc" artifact to fail. This
// makes the javadoc task to ignore those generated classes.
tasks.withType(Javadoc::class.java) {
  exclude("io/opentelemetry/proto/*")
}

// The task that generates the "sources" artifact fails due to a "duplicated io/opentelemetry/proto/metrics/v1/Exemplar.java" file
// Which is strange since there's only one file like that which is generated by wire and the main "jar" task doesn't raise the same issue.
// This allows to ignore any subsequent files with the same path when creating the "sources" artifact.
tasks.named("sourcesJar", Jar::class.java) {
  duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}
