import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

plugins {
  id("otel.java-conventions")
  id("otel.publish-conventions")
  id("otel.animalsniffer-conventions")
  id("com.gradleup.shadow")
  id("me.champeau.jmh") version "0.7.3"
  id("com.squareup.wire") version "5.4.0"
}

description = "Exporter implementations that store signals on disk"
otelJava.moduleName.set("io.opentelemetry.contrib.exporters.disk")

val protos by configurations.creating

dependencies {
  api("io.opentelemetry:opentelemetry-sdk")
  implementation("io.opentelemetry:opentelemetry-api-incubator")
  implementation("io.opentelemetry:opentelemetry-exporter-otlp-common")
  compileOnly("com.google.auto.value:auto-value-annotations")
  annotationProcessor("com.google.auto.value:auto-value")
  testImplementation("org.mockito:mockito-inline")
  testImplementation("io.opentelemetry:opentelemetry-sdk-testing")

  protos("io.opentelemetry.proto:opentelemetry-proto:1.8.0-alpha@jar")
}

jmh {
  warmupIterations.set(0)
  fork.set(2)
  iterations.set(5)
  timeOnIteration.set("5s")
  timeUnit.set("ms")
}

val setupProtos by tasks.registering(Sync::class) {
  inputs.files(protos)
  from(zipTree(protos.singleFile))
  into(layout.buildDirectory.dir("protos"))
}

wire {
  java {}

  sourcePath {
    srcDir(setupProtos)
  }

  root(
    // These are the types used by the Java SDK's OTLP exporters.
    "opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest",
    "opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest",
    "opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest",
  )
}

tasks.named<ShadowJar>("shadowJar") {
  archiveClassifier.set("")
  configurations =
    emptyList() // To avoid embedding any dependencies as we only need to rename some local packages.
  relocate("io.opentelemetry.proto", "io.opentelemetry.diskbuffering.proto")
  mustRunAfter("jar")
}

// The javadoc from wire's generated classes has errors that make the task that generates the "javadoc" artifact to fail. This
// makes the javadoc task to ignore those generated classes.
tasks.withType(Javadoc::class.java) {
  exclude("io/opentelemetry/proto/*")
}

// The task that generates the "sources" artifact fails due to a "duplicated io/opentelemetry/proto/metrics/v1/Exemplar.java" file
// Which is strange since there's only one file like that which is generated by wire and the main "jar" task doesn't raise the same issue.
// This allows to ignore any subsequent files with the same path when creating the "sources" artifact.
tasks.named("sourcesJar", Jar::class.java) {
  duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}
